\setauthor{Sebastian Radic}
\chapter{Backend-Anwendungsstruktur und Controller-Implementierung}
\label{chap:backend_structure}

Das Backend des \textit{SmartBillConverter} ist eine RESTful Web API auf Basis von ASP.NET Core 9.0. Der Aufbau folgt einem klassischen Schichtenmodell: Controller nehmen HTTP-Anfragen entgegen, Services enthalten die eigentliche Logik, und Repositories kümmern sich um den Datenbankzugriff. Dieses Kapitel zeigt, wie die einzelnen Teile technisch umgesetzt wurden.

\section{Controller-Implementierung}
\label{sec:controller_implementation}

Die Controller sind das Erste, was eine eingehende HTTP-Anfrage sieht. Sie prüfen die Anfrage, leiten die eigentliche Arbeit an die zuständigen Services weiter und schicken das Ergebnis zurück ans Frontend. Im Projekt gibt es fünf Controller, jeder für einen eigenen Aufgabenbereich.

\subsection{ProcessingController: Upload und Verarbeitungs-Orchestrierung}
\label{subsec:processing_controller}

Der \texttt{ProcessingController} ist der wichtigste Controller im Projekt. Er steuert den gesamten Ablauf von der hochgeladenen PDF-Datei bis zur fertigen XML.

\subsubsection{Struktur und Dependency Injection}
Der Controller nutzt Constructor Injection für alle Abhängigkeiten:

\begin{lstlisting}[language={[Sharp]C}, caption={ProcessingController Constructor}, label={lst:processing_constructor}]
[ApiController]
[Route("api/[controller]")]
public class ProcessingController : ControllerBase
{
    private readonly IInvoiceService _invoiceService;
    private readonly ILlmConversionService _llmConversionService;
    private readonly ILogger<ProcessingController> _logger;

    public ProcessingController(
        IInvoiceService invoiceService, 
        ILlmConversionService llmConversionService,
        ILogger<ProcessingController> logger)
    {
        _invoiceService = invoiceService;
        _llmConversionService = llmConversionService;
        _logger = logger;
    }
}
\end{lstlisting}

Die \texttt{[ApiController]}-Attribute aktiviert automatische Model-Validierung, Fehlerbehandlung und API-spezifische Routing-Konventionen. \texttt{ILogger} wird vom ASP.NET Core Framework bereitgestellt und ermöglicht strukturiertes Logging.\footnote{Vgl. Microsoft: \textit{Dependency injection in ASP.NET Core}, \url{https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection}, letzter Zugriff am 06.01.2026}

\subsubsection{Upload-Endpoint mit Validierung}
Der Haupt-Endpoint \texttt{/api/Processing/upload} akzeptiert PDF-Dateien via Multipart-Form-Data:

\begin{lstlisting}[language={[Sharp]C}, caption={Upload-Endpoint mit Validierung}, label={lst:upload_endpoint}]
[HttpPost("upload")]
[Consumes("multipart/form-data")]
[ProducesResponseType(StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
public async Task<IActionResult> UploadPdf(IFormFile file)
{
    if (file == null || file.Length == 0)
    {
        return BadRequest(new { error = "Keine Datei hochgeladen" });
    }

    if (!file.ContentType.Equals("application/pdf", 
        StringComparison.OrdinalIgnoreCase))
    {
        return BadRequest(new { error = "Nur PDF-Dateien erlaubt" });
    }

    if (file.Length > 10 * 1024 * 1024) // 10MB Limit
    {
        return BadRequest(new { error = "Datei zu gross (max. 10MB)" });
    }

    using var stream = file.OpenReadStream();
    var invoice = await _invoiceService.ProcessInvoiceAsync(
        stream, file.FileName);
    
    return Ok(new { success = true, invoice });
}
\end{lstlisting}

Die Prüfung läuft in drei Schritten: Erst wird geschaut ob eine Datei vorhanden ist, dann ob es wirklich ein PDF ist, und zuletzt ob die Datei nicht größer als 10MB ist. Das Limit ist wichtig damit der Server bei sehr großen Dateien nicht zu viel Speicher braucht. \texttt{IFormFile} ist die ASP.NET-Klasse für hochgeladene Dateien.

Die eigentliche Arbeit macht \texttt{ProcessInvoiceAsync} im \texttt{IInvoiceService}: PDF-Text extrahieren, KI aufrufen, Daten speichern. Der Controller selbst macht nur das Nötigste — die HTTP-Anfrage prüfen und das Ergebnis zurückschicken.

\subsection{InvoiceController: CRUD-Operationen}
\label{subsec:invoice_controller}

Der \texttt{InvoiceController} bietet RESTful CRUD-Endpoints für gespeicherte Rechnungen:

\begin{lstlisting}[language={[Sharp]C}, caption={InvoiceController GET-Endpoints}, label={lst:invoice_get}]
[ApiController]
[Route("api/[controller]")]
public class InvoiceController : ControllerBase
{
    private readonly IInvoiceRepository _repository;

    [HttpGet]
    public async Task<IActionResult> GetAll()
    {
        var invoices = await _repository.GetAllAsync();
        return Ok(invoices);
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(int id)
    {
        var invoice = await _repository.GetByIdAsync(id);
        if (invoice == null)
            return NotFound(new { error = $"Rechnung {id} nicht gefunden" });
        
        return Ok(invoice);
    }

    [HttpGet("search")]
    public async Task<IActionResult> Search(
        [FromQuery] string? invoiceNumber,
        [FromQuery] int? year)
    {
        var results = await _repository.SearchAsync(invoiceNumber, year);
        return Ok(results);
    }
}
\end{lstlisting}

Das \texttt{[FromQuery]}-Attribut liest URL-Parameter automatisch aus. Beispiel: \texttt{GET /api/Invoice/search?year=2024} wird zu \texttt{Search(null, 2024)}. Das Repository-Pattern verbirgt die Datenbankzugriffe hinter einer Schnittstelle, was das Testen mit Mock-Objekten einfach macht.\footnote{Vgl. Fowler, Martin: \textit{Patterns of Enterprise Application Architecture - Repository}, \url{https://martinfowler.com/eaaCatalog/repository.html}, letzter Zugriff am 06.01.2026}

\subsection{ZugferdController: Hybrides PDF/XML-Format}
\label{subsec:zugferd_controller}

Der \texttt{ZugferdController} verarbeitet PDFs speziell für das ZUGFeRD-Format:

\begin{lstlisting}[language={[Sharp]C}, caption={ZUGFeRD Upload-Endpoint}, label={lst:zugferd_upload}]
[ApiController]
[Route("api/[controller]")]
public class ZugferdController : ControllerBase
{
    private readonly IZugferdService _zugferdService;

    [HttpPost("upload-pdf")]
    [Consumes("multipart/form-data")]
    public async Task<IActionResult> UploadPdfForZugferd(IFormFile file)
    {
        if (file == null || file.Length == 0)
            return BadRequest("Keine Datei");

        using var stream = file.OpenReadStream();
        var zugferdXml = await _zugferdService.ConvertToZugferdAsync(
            stream, file.FileName);

        return Ok(new { 
            success = true, 
            zugferdXml,
            format = "ZUGFeRD 2.3 EN16931"
        });
    }
}
\end{lstlisting}

Der \texttt{ZugferdService} liest den Text aus dem PDF, schickt ihn an die KI und bekommt ZUGFeRD-konformes CII-XML zurück. Das XML wird direkt als String in der Antwort mitgeschickt, damit das Frontend es als Download anbieten kann.

\subsection{ImageProcessingController: OCR für Scans}
\label{subsec:image_controller}

Für gescannte Rechnungen (PNG, JPEG, TIFF) bietet der \texttt{ImageProcessingController} OCR-Verarbeitung:

\begin{lstlisting}[language={[Sharp]C}, caption={Image-OCR-Endpoint}, label={lst:image_ocr}]
[HttpPost("ocr")]
[Consumes("multipart/form-data")]
public async Task<IActionResult> ProcessImage(IFormFile imageFile)
{
    var supportedFormats = new[] { ".png", ".jpg", ".jpeg", ".bmp", ".tiff" };
    var extension = Path.GetExtension(imageFile.FileName).ToLower();
    
    if (!supportedFormats.Contains(extension))
        return BadRequest($"Format {extension} nicht unterstuetzt");

    var extractedText = await _ocrService.ExtractTextFromImageAsync(
        imageFile);
    
    var llmResponse = await _llmService.ConvertToXmlAsync(
        extractedText);

    return Ok(new { 
        extractedText, 
        ebInterfaceXml = llmResponse.EbInterfaceXml 
    });
}
\end{lstlisting}

Die Prüfung läuft über die Dateiendung. Tesseract kann alle gängigen Bildformate verarbeiten, aber die Erkennungsqualität hängt stark von der Auflösung ab (optimal sind 300 DPI). Der zweistufige Ablauf OCR → KI hilft dabei, OCR-Fehler im zweiten Schritt noch zu korrigieren.

\subsection{DownloadController: XML-Datei-Export}
\label{subsec:download_controller}

Der \texttt{DownloadController} liefert generierte XML-Dateien mit korrekten HTTP-Headers:

\begin{lstlisting}[language={[Sharp]C}, caption={XML-Download mit Content-Disposition}, label={lst:xml_download}]
[HttpGet("xml/{id}")]
public async Task<IActionResult> DownloadXml(int id)
{
    var invoice = await _repository.GetByIdAsync(id);
    if (invoice?.EbInterfaceXml == null)
        return NotFound();

    var xmlBytes = Encoding.UTF8.GetBytes(invoice.EbInterfaceXml);
    var fileName = $"invoice_{invoice.InvoiceNumber}_ebInterface.xml";

    return File(
        xmlBytes, 
        "application/xml", 
        fileName
    );
}
\end{lstlisting}

Die \texttt{File()}-Methode setzt automatisch den \texttt{Content-Disposition: attachment}-Header, wodurch der Browser den Download-Dialog anzeigt. Der Dateiname folgt einem sprechenden Schema für einfache Archivierung.

\section{Service-Layer Architektur}
\label{sec:service_layer}

Services enthalten die eigentliche Programmlogik. Jeder Service wird als Scoped registriert, das heißt pro HTTP-Request entsteht eine eigene Instanz und wird danach wieder aufgeräumt.

\subsection{Interface-basierte Abstraktion}
Alle Services sind über Interfaces definiert, was Dependency Inversion ermöglicht:

\begin{lstlisting}[language={[Sharp]C}, caption={Service-Interfaces}, label={lst:service_interfaces}]
public interface IInvoiceService
{
    Task<Invoice> ProcessInvoiceAsync(Stream pdfStream, string fileName);
    Task<Invoice> SaveInvoiceAsync(Invoice invoice);
}

public interface IPdfExtractionService
{
    Task<string> ExtractTextFromPdfAsync(Stream pdfStream);
}

public interface IOcrExtractionService
{
    Task<string> ExtractTextFromImageAsync(IFormFile imageFile);
    Task<string> ExtractTextFromImageAsync(Stream stream, string fileName);
}

public interface ILlmConversionService
{
    Task<LlmResponse> ConvertToXmlAsync(string extractedText);
}
\end{lstlisting}

Weil alle Services über Interfaces angesprochen werden, kann man die konkrete Implementierung jederzeit austauschen — zum Beispiel von Gemini auf GPT-4 wechseln — ohne den Controller ändern zu müssen. Das ist auch für Tests nützlich, weil man Interfaces durch einfache Mock-Objekte ersetzen kann.

\subsection{Service-Registrierung in Program.cs}
Die Services werden im Dependency Injection Container registriert:

\begin{lstlisting}[language={[Sharp]C}, caption={Service-Registrierung}, label={lst:service_registration}]
var builder = WebApplication.CreateBuilder(args);

// Services als Scoped (pro Request eine Instanz)
builder.Services.AddScoped<IInvoiceRepository, InvoiceRepository>();
builder.Services.AddScoped<IPdfExtractionService, PdfExtractionService>();
builder.Services.AddScoped<IOcrExtractionService, OcrExtractionService>();
builder.Services.AddScoped<ILlmConversionService, LlmConversionService>();
builder.Services.AddScoped<IInvoiceService, InvoiceService>();

// HttpClient fuer LLM-API mit Timeout
builder.Services.AddHttpClient<ILlmConversionService, LlmConversionService>()
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));
\end{lstlisting}

\texttt{AddScoped} heißt: Pro HTTP-Request wird eine neue Instanz erstellt und am Ende wieder gelöscht. \texttt{AddHttpClient} meldet den \texttt{HttpClient} für den \texttt{LlmConversionService} an, was automatisch Connection-Pooling und Timeout-Verwaltung mitbringt.\footnote{Vgl. Microsoft: \textit{Make HTTP requests using IHttpClientFactory}, \url{https://learn.microsoft.com/en-us/dotnet/core/extensions/httpclient-factory}, letzter Zugriff am 06.01.2026}

\subsection{InvoiceService: Orchestrierung der Pipeline}
Der \texttt{InvoiceService} koordiniert alle Verarbeitungsschritte:

\begin{lstlisting}[language={[Sharp]C}, caption={InvoiceService Pipeline}, label={lst:invoice_service}]
public class InvoiceService : IInvoiceService
{
    private readonly IPdfExtractionService _pdfService;
    private readonly ILlmConversionService _llmService;
    private readonly IInvoiceRepository _repository;
    private readonly ILogger<InvoiceService> _logger;

    public async Task<Invoice> ProcessInvoiceAsync(
        Stream pdfStream, string fileName)
    {
        // 1. Text-Extraktion
        var extractedText = await _pdfService.ExtractTextFromPdfAsync(
            pdfStream);
        
        _logger.LogInformation("Text extrahiert: {Length} Zeichen", 
            extractedText.Length);

        // 2. LLM-Konvertierung
        var llmResponse = await _llmService.ConvertToXmlAsync(
            extractedText);

        // 3. Datenbank-Speicherung
        var invoice = MapToInvoice(llmResponse.ParsedData);
        invoice.ExtractedText = extractedText;
        invoice.EbInterfaceXml = llmResponse.FinalEbInterfaceXml;
        
        await _repository.AddAsync(invoice);
        await _repository.SaveChangesAsync();

        return invoice;
    }
}
\end{lstlisting}

Der Ablauf ist gradlinig: PDF rein, Text extrahieren, KI aufrufen, in der Datenbank speichern. Nach jedem Schritt wird geloggt, damit man beim Debuggen nachvollziehen kann, wo etwas schiefgelaufen ist. \texttt{MapToInvoice} überführt die KI-Antwort in das Entity-Framework-Objekt.

\section{Repository Pattern und Datenzugriff}
\label{sec:repository_pattern}

Das Repository-Pattern abstrahiert die Datenbankzugriffe und bietet eine Collection-ähnliche Schnittstelle.

\subsection{IInvoiceRepository Interface}
Das Repository-Interface definiert alle Datenbankoperationen:

\begin{lstlisting}[language={[Sharp]C}, caption={IInvoiceRepository Definition}, label={lst:repository_interface}]
public interface IInvoiceRepository
{
    Task<Invoice?> GetByIdAsync(int id);
    Task<List<Invoice>> GetAllAsync();
    Task<List<Invoice>> SearchAsync(string? invoiceNumber, int? year);
    Task AddAsync(Invoice invoice);
    Task UpdateAsync(Invoice invoice);
    Task DeleteAsync(int id);
    Task<int> SaveChangesAsync();
}
\end{lstlisting}

Alle Methoden sind async für Non-Blocking I/O. \texttt{SaveChangesAsync()} gibt die Anzahl betroffener Rows zurück.

\subsection{Repository-Implementierung mit Entity Framework}
Die Implementierung nutzt Entity Framework Core für Datenbankzugriffe:

\begin{lstlisting}[language={[Sharp]C}, caption={InvoiceRepository Implementierung}, label={lst:repository_impl}]
public class InvoiceRepository : IInvoiceRepository
{
    private readonly ApplicationDbContext _context;

    public InvoiceRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<List<Invoice>> GetAllAsync()
    {
        return await _context.Invoices
            .OrderByDescending(i => i.InvoiceDate)
            .ToListAsync();
    }

    public async Task<List<Invoice>> SearchAsync(
        string? invoiceNumber, int? year)
    {
        var query = _context.Invoices.AsQueryable();

        if (!string.IsNullOrEmpty(invoiceNumber))
            query = query.Where(i => i.InvoiceNumber.Contains(invoiceNumber));

        if (year.HasValue)
            query = query.Where(i => i.Year == year.Value);

        return await query.ToListAsync();
    }

    public async Task AddAsync(Invoice invoice)
    {
        await _context.Invoices.AddAsync(invoice);
    }

    public async Task<int> SaveChangesAsync()
    {
        return await _context.SaveChangesAsync();
    }
}
\end{lstlisting}

\texttt{AsQueryable()} ermöglicht Query-Composition (WHERE-Bedingungen werden dynamisch aufgebaut). \texttt{ToListAsync()} führt die Query aus und materialisiert die Ergebnisse. \texttt{Contains()} wird zu SQL \texttt{LIKE} konvertiert.

\subsection{ApplicationDbContext: Entity Framework Configuration}
Der \texttt{ApplicationDbContext} definiert das Datenmodell:

\begin{lstlisting}[language={[Sharp]C}, caption={ApplicationDbContext}, label={lst:dbcontext}]
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(
        DbContextOptions<ApplicationDbContext> options) 
        : base(options)
    {
    }

    public DbSet<Invoice> Invoices { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Invoice>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.InvoiceAmount).HasPrecision(14, 2);
            entity.Property(e => e.DiscountAmount).HasPrecision(14, 2);
            entity.HasIndex(e => e.InvoiceNumber);
            entity.HasIndex(e => e.Year);
        });
    }
}
\end{lstlisting}

\texttt{HasPrecision(14, 2)} legt fest, dass Geldbeträge mit 14 Stellen und 2 Nachkommastellen gespeichert werden. Indizes auf \texttt{InvoiceNumber} und \texttt{Year} machen Suchanfragen schneller. Alle Einstellungen werden bei der nächsten Migration in Datenbankbefehle übersetzt.\footnote{Vgl. Microsoft: \textit{Entity Framework Core Documentation}, \url{https://learn.microsoft.com/en-us/ef/core/}, letzter Zugriff am 06.01.2026}

\subsection{Invoice Entity-Modell}
Die \texttt{Invoice}-Entität repräsentiert eine Rechnung in der Datenbank:

\begin{lstlisting}[language={[Sharp]C}, caption={Invoice Entity}, label={lst:invoice_entity}]
public class Invoice
{
    [Key]
    public int Id { get; set; }
    
    public short Year { get; set; }
    
    [MaxLength(20)]
    public string? InvoiceNumber { get; set; }
    
    [Column(TypeName = "decimal(14,2)")]
    public decimal InvoiceAmount { get; set; }
    
    public DateTime InvoiceDate { get; set; }
    public DateTime DueDate { get; set; }
    
    [MaxLength(20)]
    public string? VatNumber { get; set; }
    
    [MaxLength(34)]
    public string? IBAN { get; set; }
    
    [MaxLength(35)]
    public string? PaymentReference { get; set; }
    
    [NotMapped]
    public string? ExtractedText { get; set; }
    
    [NotMapped]
    public string? EbInterfaceXml { get; set; }
}
\end{lstlisting}

Properties mit \texttt{[NotMapped]} werden nicht in der Datenbank angelegt — sie sind nur im C\#-Objekt vorhanden, damit sie in der API-Antwort mitgeschickt werden können. \texttt{MaxLength} bestimmt die Länge der VARCHAR-Felder. IBANs sind nach Standard maximal 34 Zeichen lang.

\section{Konfiguration und Secrets Management}
\label{sec:configuration}

Die Anwendung nutzt ASP.NET Cores Configuration-System für Environment-spezifische Settings.

\subsection{appsettings.json: Strukturierte Konfiguration}
Die Hauptkonfiguration ist in \texttt{appsettings.json}:

\begin{lstlisting}[caption={appsettings.json}, label={lst:appsettings}]
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=smartbill;Username=postgres;Password=mypassword"
  },
  "Tesseract": {
    "DataPath": "./tessdata"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  }
}
\end{lstlisting}

Der Connection String definiert die PostgreSQL-Verbindung. \texttt{Tesseract:DataPath} zeigt auf den Ordner mit Sprachmodellen. LogLevel \texttt{Warning} für Entity Framework reduziert Verbosity.

\subsection{Environment Variables und .env-Datei}
Sensible Daten (API-Keys, Passwörter) werden via Environment Variables verwaltet:

\begin{lstlisting}[language={[Sharp]C}, caption={.env-Datei Laden}, label={lst:env_loading}]
if (builder.Environment.IsDevelopment())
{
    var envPath = Path.Combine(Directory.GetCurrentDirectory(), ".env");
    if (File.Exists(envPath))
    {
        foreach (var line in File.ReadAllLines(envPath))
        {
            if (string.IsNullOrWhiteSpace(line) || line.StartsWith("#"))
                continue;

            var parts = line.Split('=', 2);
            if (parts.Length == 2)
            {
                Environment.SetEnvironmentVariable(
                    parts[0].Trim(), parts[1].Trim());
            }
        }
    }
}
\end{lstlisting}

Die \texttt{.env}-Datei hat das Format \texttt{KEY=VALUE}. Beispiel: \texttt{GEMINI\_API\_KEY=AIzaSy...}. Die Datei ist in \texttt{.gitignore} und wird nicht committed. In Produktion werden echte Environment Variables verwendet.\footnote{Vgl. The Twelve-Factor App: \textit{III. Config - Store config in the environment}, \url{https://12factor.net/config}, letzter Zugriff am 06.01.2026}

\subsection{Verwendung in Services}
Services greifen via \texttt{IConfiguration} auf Settings zu:

\begin{lstlisting}[language={[Sharp]C}, caption={Configuration-Zugriff im Service}, label={lst:config_access}]
public class LlmConversionService : ILlmConversionService
{
    private readonly string _apiKey;
    private readonly string _apiEndpoint;

    public LlmConversionService(IConfiguration configuration)
    {
        _apiKey = Environment.GetEnvironmentVariable("GEMINI_API_KEY") 
            ?? throw new InvalidOperationException("API Key fehlt");
        
        _apiEndpoint = configuration["Gemini:Endpoint"] 
            ?? "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent";
    }
}
\end{lstlisting}

Der Null-Coalescing-Operator \texttt{??} liefert einen Fallback-Wert. \texttt{throw} bei fehlendem API-Key verhindert Startup mit invalider Konfiguration (Fail-Fast-Prinzip).

\section{Fehlerbehandlung und Logging}
\label{sec:error_handling}

Robuste Fehlerbehandlung und strukturiertes Logging sind kritisch für Production-Systeme.

\subsection{Try-Catch-Pattern in Controllern}
Alle Controller-Methoden haben Try-Catch-Blöcke:

\begin{lstlisting}[language={[Sharp]C}, caption={Controller-Fehlerbehandlung}, label={lst:controller_error}]
[HttpPost("upload")]
public async Task<IActionResult> UploadPdf(IFormFile file)
{
    try
    {
        // Validierung
        if (file == null || file.Length == 0)
            return BadRequest(new { error = "Keine Datei" });

        // Verarbeitung
        using var stream = file.OpenReadStream();
        var invoice = await _invoiceService.ProcessInvoiceAsync(
            stream, file.FileName);

        return Ok(new { success = true, invoice });
    }
    catch (InvalidOperationException ex)
    {
        _logger.LogError(ex, "Verarbeitungsfehler bei {FileName}", 
            file?.FileName);
        return StatusCode(500, new { 
            error = "Verarbeitung fehlgeschlagen", 
            details = ex.Message 
        });
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Unerwarteter Fehler");
        return StatusCode(500, new { 
            error = "Interner Serverfehler" 
        });
    }
}
\end{lstlisting}

Bekannte Fehler wie \texttt{InvalidOperationException} werden zuerst abgefangen und dem Benutzer mit einer verständlichen Nachricht angezeigt. Der zweite \texttt{catch}-Block fängt alle anderen unerwarteten Fehler. HTTP-Status 500 bedeutet, dass der Server selbst einen Fehler hatte.

\subsection{Strukturiertes Logging mit ILogger}
ASP.NET Cores \texttt{ILogger} bietet strukturiertes Logging:

\begin{lstlisting}[language={[Sharp]C}, caption={Strukturiertes Logging}, label={lst:structured_logging}]
public async Task<string> ExtractTextFromPdfAsync(Stream pdfStream)
{
    _logger.LogInformation(
        "PDF-Extraktion gestartet. Stream-Groesse: {Size} bytes", 
        pdfStream.Length);

    try
    {
        using var document = PdfDocument.Open(pdfStream);
        
        _logger.LogInformation(
            "PDF geoeffnet: {PageCount} Seiten", 
            document.NumberOfPages);

        // ... Extraktion ...

        _logger.LogInformation(
            "Extraktion abgeschlossen: {CharCount} Zeichen", 
            extractedText.Length);

        return extractedText;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, 
            "PDF-Extraktion fehlgeschlagen");
        throw new InvalidOperationException(
            "PDF konnte nicht verarbeitet werden", ex);
    }
}
\end{lstlisting}

Die geschweiften Klammern wie \texttt{\{PageCount\}} sind Platzhalter für Werte, die beim Ausführen eingesetzt werden. So können die Logs später nach bestimmten Werten durchsucht werden. \texttt{LogError} schreibt automatisch auch den Stack-Trace mit, was bei der Fehlersuche sehr nützlich ist.\footnote{Vgl. Microsoft: \textit{Logging in .NET Core and ASP.NET Core}, \url{https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging/}, letzter Zugriff am 06.01.2026}

\subsection{HTTP-Statuscodes und Best Practices}
Die Anwendung nutzt semantische HTTP-Statuscodes:

\begin{itemize}
    \item \textbf{200 OK}: Erfolgreiche Verarbeitung mit Daten
    \item \textbf{400 Bad Request}: Client-Fehler (fehlende Datei, falsches Format)
    \item \textbf{404 Not Found}: Ressource existiert nicht
    \item \textbf{500 Internal Server Error}: Server-Fehler (PDF-Extraktion fehlgeschlagen)
\end{itemize}

Error-Responses haben ein konsistentes Format:

\begin{lstlisting}[caption={Error-Response-Format}]
{
  "error": "Kurze Fehlerbeschreibung",
  "details": "Detaillierte technische Info (optional)"
}
\end{lstlisting}

Dies ermöglicht dem Frontend einheitliches Error-Handling.

\subsection{CORS-Konfiguration für Frontend-Kommunikation}
Cross-Origin Resource Sharing (CORS) erlaubt dem Angular-Frontend (Port 4200) API-Zugriff (Port 5000):

\begin{lstlisting}[language={[Sharp]C}, caption={CORS-Policy}, label={lst:cors_policy}]
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowFrontend", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});

var app = builder.Build();
app.UseCors("AllowFrontend");
\end{lstlisting}

\texttt{AllowAnyOrigin()} ist für Development akzeptabel. In Production sollte die Origin auf die konkrete Frontend-URL beschränkt werden: \texttt{.WithOrigins("https://smartbill.com")}. \texttt{AllowAnyMethod()} erlaubt GET, POST, PUT, DELETE.\footnote{Vgl. Mozilla: \textit{Cross-Origin Resource Sharing (CORS)}, \url{https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS}, letzter Zugriff am 06.01.2026}
